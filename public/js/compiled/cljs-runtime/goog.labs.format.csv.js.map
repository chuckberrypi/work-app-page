{
"version":3,
"file":"goog.labs.format.csv.js",
"lineCount":192,
"mappings":"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",
"sources":["goog/labs/format/csv.js"],
"sourcesContent":["/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Provides a parser that turns a string of well-formed CSV data\n * into an array of objects or an array of arrays. All values are returned as\n * strings; the user has to convert data into numbers or Dates as required.\n * Empty fields (adjacent commas) are returned as empty strings.\n *\n * This parser uses http://tools.ietf.org/html/rfc4180 as the definition of CSV.\n */\n\n// TODO(user): We're trying to migrate all ES5 subclasses of Closure\n// Library to ES6. In ES6 this cannot be referenced before super is called. This\n// file has at least one this before a super call (in ES5) and cannot be\n// automatically upgraded to ES6 as a result. Please fix this if you have a\n// chance. Note: This can sometimes be caused by not calling the super\n// constructor at all. You can run the conversion tool yourself to see what it\n// does on this file: blaze run //javascript/refactoring/es6_classes:convert.\n\ngoog.provide('goog.labs.format.csv');\ngoog.provide('goog.labs.format.csv.ParseError');\ngoog.provide('goog.labs.format.csv.Token');\n\ngoog.require('goog.asserts');\ngoog.require('goog.debug.Error');\ngoog.require('goog.object');\ngoog.require('goog.string');\ngoog.require('goog.string.newlines');\n\n\n/**\n * @define {boolean} Enable verbose debugging. This is a flag so it can be\n * enabled in production if necessary post-compilation.  Otherwise, debug\n * information will be stripped to minimize final code size.\n */\ngoog.labs.format.csv.ENABLE_VERBOSE_DEBUGGING = goog.DEBUG;\n\n\n\n/**\n * Error thrown when parsing fails.\n *\n * @param {string} text The CSV source text being parsed.\n * @param {number} index The index, in the string, of the position of the\n *      error.\n * @param {string=} opt_message A description of the violated parse expectation.\n * @constructor\n * @extends {goog.debug.Error}\n * @final\n */\ngoog.labs.format.csv.ParseError = function(text, index, opt_message) {\n  'use strict';\n  let message;\n\n  /**\n   * @type {?{line: number, column: number}} The line and column of the parse\n   *     error.\n   */\n  this.position = null;\n\n  if (goog.labs.format.csv.ENABLE_VERBOSE_DEBUGGING) {\n    message = opt_message || '';\n\n    const info = goog.labs.format.csv.ParseError.findLineInfo_(text, index);\n    if (info) {\n      const lineNumber = info.lineIndex + 1;\n      const columnNumber = index - info.line.startLineIndex + 1;\n\n      this.position = {line: lineNumber, column: columnNumber};\n\n      message +=\n          goog.string.subs(' at line %s column %s', lineNumber, columnNumber);\n      message += '\\n' +\n          goog.labs.format.csv.ParseError.getLineDebugString_(\n              info.line.getContent(), columnNumber);\n    }\n  }\n\n  goog.labs.format.csv.ParseError.base(this, 'constructor', message);\n};\ngoog.inherits(goog.labs.format.csv.ParseError, goog.debug.Error);\n\n\n/** @inheritDoc */\ngoog.labs.format.csv.ParseError.prototype.name = 'ParseError';\n\n\n/**\n * Calculate the line and column for an index in a string.\n * TODO(nnaze): Consider moving to goog.string.newlines.\n * @param {string} str A string.\n * @param {number} index An index into the string.\n * @return {?{line: !goog.string.newlines.Line, lineIndex: number}} The line\n *     and index of the line.\n * @private\n */\ngoog.labs.format.csv.ParseError.findLineInfo_ = function(str, index) {\n  'use strict';\n  const lines = goog.string.newlines.getLines(str);\n  const lineIndex = lines.findIndex(function(line) {\n    'use strict';\n    return line.startLineIndex <= index && line.endLineIndex > index;\n  });\n\n  if (typeof (lineIndex) === 'number') {\n    const line = lines[lineIndex];\n    return {line: line, lineIndex: lineIndex};\n  }\n\n  return null;\n};\n\n\n/**\n * Get a debug string of a line and a pointing caret beneath it.\n * @param {string} str The string.\n * @param {number} column The column to point at (1-indexed).\n * @return {string} The debug line.\n * @private\n */\ngoog.labs.format.csv.ParseError.getLineDebugString_ = function(str, column) {\n  'use strict';\n  let returnString = str + '\\n';\n  returnString += goog.string.repeat(' ', column - 1) + '^';\n  return returnString;\n};\n\n\n/**\n * A token -- a single-character string or a sentinel.\n * @typedef {string|!goog.labs.format.csv.Sentinels_}\n */\ngoog.labs.format.csv.Token;\n\n\n/**\n * Parses a CSV string to create a two-dimensional array.\n *\n * This function does not process header lines, etc -- such transformations can\n * be made on the resulting array.\n *\n * @param {string} text The entire CSV text to be parsed.\n * @param {boolean=} opt_ignoreErrors Whether to ignore parsing errors and\n *      instead try to recover and keep going.\n * @param {string=} opt_delimiter The delimiter to use. Defaults to ','\n * @return {!Array<!Array<string>>} The parsed CSV.\n */\ngoog.labs.format.csv.parse = function(text, opt_ignoreErrors, opt_delimiter) {\n  'use strict';\n  let index = 0;  // current char offset being considered\n\n  const delimiter = opt_delimiter || ',';\n  goog.asserts.assert(\n      delimiter.length == 1, 'Delimiter must be a single character.');\n  goog.asserts.assert(\n      delimiter != '\\r' && opt_delimiter != '\\n',\n      'Cannot use newline or carriage return as delimiter.');\n\n  const EOF = goog.labs.format.csv.Sentinels_.EOF;\n  const EOR = goog.labs.format.csv.Sentinels_.EOR;\n  const NEWLINE = goog.labs.format.csv.Sentinels_.NEWLINE;  // \\r?\\n\n  const EMPTY = goog.labs.format.csv.Sentinels_.EMPTY;\n\n  let pushBackToken = null;  // A single-token pushback.\n  let sawComma = false;      // Special case for terminal comma.\n\n  /**\n   * Push a single token into the push-back variable.\n   * @param {goog.labs.format.csv.Token} t Single token.\n   */\n  function pushBack(t) {\n    goog.labs.format.csv.assertToken_(t);\n    goog.asserts.assert(pushBackToken === null);\n    pushBackToken = t;\n  }\n\n  /**\n   * @return {goog.labs.format.csv.Token} The next token in the stream.\n   */\n  function nextToken() {\n    // Give the push back token if present.\n    if (pushBackToken != null) {\n      const c = pushBackToken;\n      pushBackToken = null;\n      return c;\n    }\n\n    // We're done. EOF.\n    if (index >= text.length) {\n      return EOF;\n    }\n\n    // Give the next charater.\n    const chr = text.charAt(index++);\n    goog.labs.format.csv.assertToken_(chr);\n\n    // Check if this is a newline.  If so, give the new line sentinel.\n    let isNewline = false;\n    if (chr == '\\n') {\n      isNewline = true;\n    } else if (chr == '\\r') {\n      // This is a '\\r\\n' newline. Treat as single token, go\n      // forward two indicies.\n      if (index < text.length && text.charAt(index) == '\\n') {\n        index++;\n      }\n\n      isNewline = true;\n    }\n\n    if (isNewline) {\n      return NEWLINE;\n    }\n\n    return chr;\n  }\n\n  /**\n   * Read a quoted field from input.\n   * @return {string} The field, as a string.\n   */\n  function readQuotedField() {\n    // We've already consumed the first quote by the time we get here.\n    const start = index;\n    let end = null;\n\n    for (let token = nextToken(); token != EOF; token = nextToken()) {\n      if (token == '\"') {\n        end = index - 1;\n        token = nextToken();\n\n        // Two double quotes in a row.  Keep scanning.\n        if (token == '\"') {\n          end = null;\n          continue;\n        }\n\n        // End of field.  Break out.\n        if (token == delimiter || token == EOF || token == NEWLINE) {\n          if (token == NEWLINE) {\n            pushBack(token);\n          }\n          if (token == delimiter) {\n            sawComma = true;\n          }\n          break;\n        }\n\n        if (!opt_ignoreErrors) {\n          // Ignoring errors here means keep going in current field after\n          // closing quote. E.g. \"ab\"c,d splits into abc,d\n          throw new goog.labs.format.csv.ParseError(\n              text, index - 1,\n              'Unexpected character \"' + token + '\" after quote mark');\n        } else {\n          // Fall back to reading the rest of this field as unquoted.\n          // Note: the rest is guaranteed not start with \", as that case is\n          // eliminated above.\n          const prefix = '\"' + text.substring(start, index);\n          const suffix = readField();\n          if (suffix == EOR) {\n            pushBack(NEWLINE);\n            return prefix;\n          } else {\n            return prefix + suffix;\n          }\n        }\n      }\n    }\n\n    if (end === null) {\n      if (!opt_ignoreErrors) {\n        throw new goog.labs.format.csv.ParseError(\n            text, text.length - 1, 'Unexpected end of text after open quote');\n      } else {\n        end = text.length;\n      }\n    }\n\n    // Take substring, combine double quotes.\n    return text.substring(start, end).replace(/\"\"/g, '\"');\n  }\n\n  /**\n   * Read a field from input.\n   * @return {string|!goog.labs.format.csv.Sentinels_} The field, as a string,\n   *     or a sentinel (if applicable).\n   */\n  function readField() {\n    const start = index;\n    const didSeeComma = sawComma;\n    sawComma = false;\n    let token = nextToken();\n    if (token == EMPTY) {\n      return EOR;\n    }\n    if (token == EOF || token == NEWLINE) {\n      if (didSeeComma) {\n        pushBack(EMPTY);\n        return '';\n      }\n      return EOR;\n    }\n\n    // This is the beginning of a quoted field.\n    if (token == '\"') {\n      return readQuotedField();\n    }\n\n    while (true) {\n      // This is the end of line or file.\n      if (token == EOF || token == NEWLINE) {\n        pushBack(token);\n        break;\n      }\n\n      // This is the end of record.\n      if (token == delimiter) {\n        sawComma = true;\n        break;\n      }\n\n      if (token == '\"' && !opt_ignoreErrors) {\n        throw new goog.labs.format.csv.ParseError(\n            text, index - 1, 'Unexpected quote mark');\n      }\n\n      token = nextToken();\n    }\n\n\n    const returnString = (token == EOF) ?\n        text.substring(start) :  // Return to end of file.\n        text.substring(start, index - 1);\n\n    return returnString.replace(/[\\r\\n]+/g, '');  // Squash any CRLFs.\n  }\n\n  /**\n   * Read the next record.\n   * @return {!Array<string>|!goog.labs.format.csv.Sentinels_} A single record\n   *     with multiple fields.\n   */\n  function readRecord() {\n    if (index >= text.length) {\n      return EOF;\n    }\n    const record = [];\n    for (let field = readField(); field != EOR; field = readField()) {\n      record.push(field);\n    }\n    return record;\n  }\n\n  // Read all records and return.\n  const records = [];\n  for (let record = readRecord(); record != EOF; record = readRecord()) {\n    records.push(record);\n  }\n  return records;\n};\n\n\n/**\n * Sentinel tracking objects.\n * @enum {!Object}\n * @private\n */\ngoog.labs.format.csv.Sentinels_ = {\n  /** Empty field */\n  EMPTY: {},\n\n  /** End of file */\n  EOF: {},\n\n  /** End of record */\n  EOR: {},\n\n  /** Newline. \\r?\\n */\n  NEWLINE: {}\n};\n\n\n/**\n * @param {string} str A string.\n * @return {boolean} Whether the string is a single character.\n * @private\n */\ngoog.labs.format.csv.isCharacterString_ = function(str) {\n  'use strict';\n  return typeof str === 'string' && str.length == 1;\n};\n\n\n/**\n * Assert the parameter is a token.\n * @param {*} o What should be a token.\n * @throws {goog.asserts.AssertionError} If {@ code} is not a token.\n * @private\n */\ngoog.labs.format.csv.assertToken_ = function(o) {\n  'use strict';\n  if (typeof o === 'string') {\n    goog.asserts.assertString(o);\n    goog.asserts.assert(\n        goog.labs.format.csv.isCharacterString_(o),\n        'Should be a string of length 1 or a sentinel.');\n  } else {\n    goog.asserts.assert(\n        goog.object.containsValue(goog.labs.format.csv.Sentinels_, o),\n        'Should be a string of length 1 or a sentinel.');\n  }\n};\n"],
"names":["goog","provide","require","labs","format","csv","ENABLE_VERBOSE_DEBUGGING","DEBUG","ParseError","goog.labs.format.csv.ParseError","text","index","opt_message","message","position","info","findLineInfo_","lineNumber","lineIndex","columnNumber","line","startLineIndex","column","string","subs","getLineDebugString_","getContent","base","inherits","debug","Error","prototype","name","goog.labs.format.csv.ParseError.findLineInfo_","str","lines","newlines","getLines","findIndex","endLineIndex","goog.labs.format.csv.ParseError.getLineDebugString_","returnString","repeat","Token","parse","goog.labs.format.csv.parse","opt_ignoreErrors","opt_delimiter","delimiter","asserts","assert","length","EOF","Sentinels_","EOR","NEWLINE","EMPTY","pushBackToken","sawComma","pushBack","t","assertToken_","nextToken","c","chr","charAt","isNewline","readQuotedField","start","end","token","prefix","substring","suffix","readField","replace","didSeeComma","readRecord","record","field","push","records","isCharacterString_","goog.labs.format.csv.isCharacterString_","goog.labs.format.csv.assertToken_","o","assertString","object","containsValue"]
}
