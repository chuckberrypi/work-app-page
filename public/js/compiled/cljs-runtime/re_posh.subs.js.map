{"version":3,"sources":["re_posh/subs.cljc"],"mappings":"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","names":["js/re-posh","js/re-posh.subs","js/re-posh.subs.execute-sub","method-table__5642__auto__","cljs.core.atom","prefer-table__5643__auto__","method-cache__5644__auto__","cached-hierarchy__5645__auto__","hierarchy__5646__auto__","cljs.core.get","fexpr__31376","cljs.core/MultiFn","cljs.core.symbol","re-posh.subs/execute-sub","p__31377","map__31378","cljs.core/--destructure-map","query","variables","pre-q","cljs.core/deref","cljs.core.partial","posh.reagent/q","re-posh.db/store","cljs.core.apply","cljs.core.into","p__31379","map__31380","pattern","id","posh.reagent/pull","p__31381","map__31382","ids","posh.reagent/pull-many","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","re-posh.subs/reg-sub","seq31383","G__31384","cljs.core/first","cljs.core/next","self__5754__auto__","query-id","args","config-fn","cljs.core/last","input-args","cljs.core/butlast","err-header","inputs-fn","G__31385","cljs.core/count","_","f","cljs.core/fn?","re_frame.loggers.console","vec__31386","cljs.core.nth","marker","vec","cljs.core._EQ_","re_frame.core.subscribe","pairs","cljs.core.partition","markers","cljs.core.map","vecs","cljs.core/every?","cljs.core/vector?","re-frame.core/subscribe","re-frame.core/reg-sub-raw","params","G__31389","G__31390","reagent.ratom/make-reaction","inputs","signals","cljs.core/seq?","re-posh.subs/reg-query-sub","sub-name","re_posh.subs.reg_sub","p__31391","vec__31392","seq__31393","cljs.core/seq","first__31394","re-posh.subs/reg-pull-sub","p__31395","vec__31396","re-posh.subs/reg-pull-many-sub","p__31399","vec__31400"],"sourcesContent":["(ns re-posh.subs\n  (:require\n   [re-frame.core :as r]\n   [re-frame.loggers :refer [console]]\n   [re-posh.db :refer [store]]\n   [reagent.ratom :refer-macros [reaction]]\n   [posh.reagent  :as p]))\n\n(defmulti execute-sub :type)\n\n(defmethod execute-sub :query\n  [{:keys [query variables]}]\n  (let [pre-q (partial p/q query @store)]\n    (apply pre-q (into [] variables))))\n\n(defmethod execute-sub :pull\n  [{:keys [pattern id]}]\n  (p/pull @store pattern id))\n\n(defmethod execute-sub :pull-many\n  [{:keys [pattern ids]}]\n  (p/pull-many @store pattern ids))\n\n(defn reg-sub\n  \"For a given `query-id` register a `config` function and input `signals`\n\n  At an abstract level, a call to this function allows you to register 'the mechanism'\n  to later fulfil a call to `(subscribe [query-id ...])`.\n\n  To say that another way, reg-sub allows you to create a template for a node\n  in the signal graph. But note: reg-sub does not cause a node to be created.\n  It simply allows you to register the template from which such a\n  node could be created, if it were needed, sometime later, when the call\n  to `subscribe` is made.\n\n  reg-sub needs three things:\n    - a `query-id`\n    - the required inputs for this node\n    - a function that generates config for query or pull for this node\n\n  The `query-id` is always the 1st argument to reg-sub and it is typically\n  a namespaced keyword.\n\n  A config function is always the last argument and it has this general form:\n  `(input-signals, query-vector) -> a-value`\n\n  What goes in between the 1st and last args can vary, but whatever is there will\n  define the input signals part of the template, and, as a result, it will control\n  what values the config functions gets as a first argument.\n  There's 3 ways this function can be called - 3 ways to supply input signals:\n\n  1. No input signals given:\n\n     (reg-sub\n       :query-id\n       a-config-fn)   ;; (fn [db v]  ... a-value)\n     The node's input signal defaults to datascript database, and the value within `ds` is\n     is given as the 1st argument to the computation function.\n\n  2. A signal function is supplied:\n\n     (reg-sub\n       :query-id\n       signal-fn     ;; <-- here, the form is (fn [db v] ... signal | [signal])\n       config-fn)\n\n     When a node is created from the template, the `signal-fn` will be called and it\n     is expected to return the input signal(s) as either a singleton, if there is only\n     one, or a sequence if there are many.\n     The values from the nominated signals will be supplied as the 1st argument to the\n     config function - either a singleton or sequence, paralleling\n     the structure returned by the signal function.\n     Here, is an example signal-fn, which returns a vector of input signals.\n       (fn [query-vec]\n         [(subscribe [:a-sub])\n          (subscribe [:b-sub])])\n     For that signal function, the config function must be written\n     to expect a vector of values for its first argument.\n       (fn [[a b] _] ....)\n     If the signal function was simpler and returned a singleton, like this:\n        (fn [query-vec dynamic-vec]\n          (subscribe [:a-sub]))\n     then the config function must be written to expect a single value\n     as the 1st argument:\n        (fn [a _] ...)\n\n  3. Syntax Sugar\n\n     (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] [_]] {:a a :b b}))\n\n  This 3rd variation is syntactic sugar for the 2nd. Pairs are supplied instead\n  of an `input signals` functions. Each pair starts with a `:<-` and a subscription\n  vector follows.\n  \"\n  [query-id & args]\n  (let [config-fn  (last args)\n        input-args (butlast args)\n        err-header (str \"re-posh: reg-sub for \" query-id \", \")\n        inputs-fn  (case (count input-args)\n                     ;; no `inputs` function provided - give the default\n                     0 (fn\n                         ([_] nil)\n                         ([_ _] nil))\n\n                     ;; a single `inputs` fn\n                     1 (let [f (first input-args)]\n                         (when-not (fn? f)\n                           (console :error err-header \"2nd argument expected to ba an inputs function, got: \" f))\n                         f)\n\n                     ;; one sugar pair\n                     2 (let [[marker vec] input-args]\n                         (when-not (= :<- marker)\n                           (console :error err-header \"expected :<-, got: \" marker))\n                         (fn inp-fn\n                           ([_] (r/subscribe vec))\n                           ([_ _] (r/subscribe vec))))\n\n                     ;; multiple sugar pairs\n                     (let [pairs (partition 2 input-args)\n                           markers (map first pairs)\n                           vecs (map last pairs)]\n                       (when-not (and (every? #{:<-} markers) (every? vector? vecs))\n                         (console :error err-header \"expected pairs of :<- and vectors, got:\" pairs))\n                       (fn inp-fn\n                         ([_] (map r/subscribe vecs))\n                         ([_ _] (map r/subscribe vecs)))))]\n    (r/reg-sub-raw\n     query-id\n     (fn [_ params]\n       (if (= (count input-args) 0)\n         ;; if there is no inputs-fn provided (or sugar version) don't wrap anything in reaction,\n         ;; just return posh's query or pull\n         (execute-sub (config-fn @@store params))\n         (reaction\n          (let [inputs (inputs-fn params)\n                signals (if (seq? inputs)\n                          (map deref inputs)\n                          (deref inputs))]\n            @(execute-sub (config-fn signals params)))))))))\n\n(defn reg-query-sub\n  \"Syntax sugar for writing queries. It allows writing query subscription\n   in a very simple way:\n\n  (re-posh/reg-query-sub\n   :query-id\n   '[:find ...\n     :in $ $1 $2  ;; <- all variables go here\n     :where ...])\n\n  It's possible to subscibe to this query with\n\n  (re-posh/subscribe [:query-id var-1 var-2])\n\n  so that variables `var-1` and `var-2` will be automatically sent to `:in` form\n  \"\n  [sub-name query]\n  (reg-sub\n   sub-name\n   (fn [_ [_ & params]]\n     {:type      :query\n      :query     query\n      :variables params})))\n\n(defn reg-pull-sub\n  \"Syntax sugar for writing pull queries. It allows writing pull subscription\n  in a very simple way:\n\n  (re-posh/reg-pull-sub\n   :pull-id\n   '[*]) ;;<- pull pattern\n\n  It's possible to subscribe to this pull query with\n\n  (re-posh/subscibe [:pull-id id])\n\n  Where id is an entity id\"\n  [sub-name pattern]\n  (reg-sub\n   sub-name\n   (fn [_ [_ id]]\n     {:type    :pull\n      :pattern pattern\n      :id      id})))\n\n(defn reg-pull-many-sub\n  \"Syntax sugar for writing pull-many queries.\n  Same as reg-pull-sub but takes vector of eids under key :ids\n\n  (reg-pull-many-sub\n   :things\n   '[*])\n\n  It's possible to subscribe to this pull-many query with\n\n  (re-posh/subscribe [:things ids])\n\n  Where ids is a sequence of entity ids\"\n  [sub-name pattern]\n  (reg-sub\n   sub-name\n   (fn [_ [_ ids]]\n     {:type    :pull-many\n      :pattern pattern\n      :ids     ids})))\n"]}