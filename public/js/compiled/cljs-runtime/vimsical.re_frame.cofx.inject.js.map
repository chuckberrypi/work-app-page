{"version":3,"sources":["vimsical/re_frame/cofx/inject.cljc"],"mappings":";AAgBA,sDAAA,tDAAOA,oHACJC;AADH,AAEE,OAAA,uGAAiB,AAACC,eAAKD;;AAGzB;;;8CAAA,9CAAOE,oGAEJF,aAAaG;AAFhB,AAIK,GAAU,AAACC,cAAI,AAAWD;AAA1B;;AAAA,AACE,oBAAU,AAACJ,oDAAgBC;AAA3B;AAAA,AACE,8DAAA,uGAAA,rKAACK,2MAAoDL;;;AACvD,OAACM,+BAA0BH;;;AAGlC,GAAA,QAAAI,qCAAAC,8CAAAC,mDAAAC,0DAAAC;AAAA;AAAA,AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uCAAA,iBAAAC,6BAAA,AAAAC,6CAAA,lIAAoBS;IAApBR,6BAAA,AAAAD,6CAAA;IAAAE,6BAAA,AAAAF,6CAAA;IAAAG,iCAAA,AAAAH,6CAAA;IAAAI,0BAAA,AAAAC,4CAAA,mCAAA,gEAAA,iBAAAC,eAAA;AAAA,AAAA,QAAAA,6CAAAA,+CAAAA;;AAAA,AAAA,YAAAC,kBAAA,AAAAC,+CAAA,gCAAA,UAqDE,WAAKE,UAAUC;AAAf,AACE,GACE,AAACC,wBAAQD;AADX;;AAAA,GAEE,AAACE,qBAAKF;AAFR;;AAAA;;;GAtDJ,4DAAAP,wBAAAL,2BAAAE,2BAAAC,2BAAAC;;;AA2DA,AAAAM,iFAAA,+HAAA,qBAAAK,VACGJ;AADH,AAAA,IAAAK,aAAAD;SAAA,AAAAE,4CAAAD,WAAA,IAAA,hEACcE;mBADdF,fACqB5B;AADrB,AAEE,IAAM+B,MAAI,AAACC,sDAAmBhC;IACxBiC,MAAI,AAACC,gBAAMH;AADjB,AAEE,AAAC7B,4CAAcF,aAAa+B;;AAC5B,OAACI,8CAAMZ,UAAUO,GAAGG;;AAGxB,AAAAX,iFAAA,iJAAA,WAAAc,SACiCI;AADjC,AAAA,IAAAH,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;gBAAAA,ZACsBd;YADtB,AAAAL,4CAAAmB,eAAA,nEACWE;AADX,AAEE,IAAAE,qBAAgC,CAACD,0DAAAA,iEAAAA,TAAuBD,6CAAAA;AAAxD,AAAA,GAAA,CAAAE,sBAAA;AAKElB;;AALF,IAAAmB,aAAAD;SAAA,AAAAZ,4CAAAa,WAAA,IAAA,hEAAWZ;mBAAXY,fAAkB1C;AAAlB,AACE,IAAM+B,MAAI,AAACC,sDAAmBhC;IACxBiC,MAAI,AAACC,gBAAMH;AADjB,AAEE,AAAC7B,4CAAcF,aAAa+B;;AAC5B,OAACI,8CAAMZ,UAAUO,GAAGG;;;AAO1B,uBAAA,vBAACU,kIAAwBrB","names":["vimsical.re-frame.cofx.inject/ignore-dispose?","query-vector","cljs.core/meta","vimsical.re-frame.cofx.inject/dispose-maybe","ratom-or-reaction","cljs.core/seq","re_frame.loggers.console","re-frame.interop/dispose!","js/vimsical","js/vimsical.re-frame","js/vimsical.re-frame.cofx","js/vimsical.re-frame.cofx.inject","js/vimsical.re-frame.cofx.inject.inject","method-table__5642__auto__","cljs.core.atom","prefer-table__5643__auto__","method-cache__5644__auto__","cached-hierarchy__5645__auto__","hierarchy__5646__auto__","cljs.core.get","fexpr__29895","cljs.core/MultiFn","cljs.core.symbol","vimsical.re-frame.cofx.inject/inject","coeffects","query-vector-or-event->query-vector-fn","cljs.core/vector?","cljs.core/ifn?","p__29901","vec__29903","cljs.core.nth","id","sub","re_frame.core.subscribe","val","cljs.core/deref","cljs.core.assoc","p__29906","map__29907","cljs.core/--destructure-map","event","event->query-vector-fn","temp__5806__auto__","vec__29909","re-frame.core/reg-cofx"],"sourcesContent":["(ns vimsical.re-frame.cofx.inject\n  \"Inject a subscription in an event handler.\n\n  *** Performance caveat ***\n\n  Do not inject subscriptions unless they are also used in a component.\n\n  For more details refer to the docstring for `inject` and for some context\n  https://github.com/Day8/re-frame/issues/255#issuecomment-299318797\n  \"\n  (:require\n   [re-frame.core :as re-frame]\n   [re-frame.loggers :refer [console]]\n   [re-frame.interop :as re-frame.interop]))\n\n\n(defn- ignore-dispose?\n  [query-vector]\n  (:ignore-dispose (meta query-vector)))\n\n\n(defn- dispose-maybe\n  \"Dispose of `ratom-or-reaction` iff it has no watches.\"\n  [query-vector ratom-or-reaction]\n  #?(:cljs\n     (when-not (seq (.-watches ratom-or-reaction))\n       (when-not (ignore-dispose? query-vector)\n         (console :warn \"Disposing of injected subscription:\" query-vector))\n       (re-frame.interop/dispose! ratom-or-reaction))))\n\n\n(defmulti ^:private inject\n  \"Inject the `:sub` cofx.\n\n  If `query-vector-or-event->query-vector-fn` is a subscription vector, subscribe and\n  dereference that subscription before assoc'ing its value in the coeffects map\n  under the id of the subscription and disposing of it.\n\n  If `query-vector-or-event->query-vector-fn` is a fn, it should take a single\n  argument which is the event args vector for that handler (similar to the\n  2-arity of `re-frame.core/reg-sub`). Its return value should be a query-vector\n  or nil. From there on the behavior is similar to when passing a query-vector.\n\n  NOTE that if there are no components subscribed to that subscription the cofx\n  will dispose of it in order to prevent leaks. However there is a performance\n  penalty to doing this since we pay for a re-frame subscription cache miss\n  every time we inject it. In such cases the cofx will log a warning which can\n  be ignored by setting `:ignore-dispose` on the subscription vector's meta. A\n  rule of thumb for what to do here would be that if an injected sub is disposed\n  of very often, we should either rework the subscription graph so that it ends\n  up used by a component and thus cached, or we should extract the db lookup\n  logic into a function that can be used to get the value straight from the db\n  inside the handler. It seems safe to decide to ignore the warning when the\n  disposal doesn't happen too often and it is just more convenient to reuse the\n  subscription's logic.\n\n  Examples:\n\n  (require '[vimsical.re-frame.cofx.inject :as inject])\n\n  ;; Injecting a simple subscription:\n\n  (re-frame/reg-sub ::simple ...)\n\n  (re-frame/reg-event-fx\n   ::simple-handler\n   [(re-frame/inject-cofx ::inject/sub [::simple]]]\n   (fn [{:as cofx {::keys [simple]} params]\n     ...)\n\n\n  ;; Injecting a dynamic subscription depending on the event parameters:\n\n  (re-frame/reg-sub ::dynamic (fn [_ [_ arg1 arg2]] ...))\n\n  (re-frame/reg-event-fx\n   ::dynamic-handler\n   [(re-frame/inject-cofx ::inject/sub\n      (fn [[_ arg1 arg2]]\n        ...\n        [::dynamic arg1 arg2]))]\n   (fn [{:as cofx {::keys [dynamic]} [_ arg1 arg-2]]\n     ...)\n  \"\n  (fn [coeffects query-vector-or-event->query-vector-fn]\n    (cond\n      (vector? query-vector-or-event->query-vector-fn) ::query-vector\n      (ifn? query-vector-or-event->query-vector-fn)    ::event->query-vector-fn)))\n\n\n(defmethod inject ::query-vector\n  [coeffects [id :as query-vector]]\n  (let [sub (re-frame/subscribe query-vector)\n        val (deref sub)]\n    (dispose-maybe query-vector sub)\n    (assoc coeffects id val)))\n\n\n(defmethod inject ::event->query-vector-fn\n  [{:keys [event] :as coeffects} event->query-vector-fn]\n  (if-some [[id :as query-vector] (event->query-vector-fn event)]\n    (let [sub (re-frame/subscribe query-vector)\n          val (deref sub)]\n      (dispose-maybe query-vector sub)\n      (assoc coeffects id val))\n    coeffects))\n\n;;\n;; * Entry point\n;;\n\n(re-frame/reg-cofx ::sub inject)\n"]}