{"version":3,"sources":["malli/generator.cljc"],"mappings":"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","names":["malli$generator$Generator$_generator$dyn","x__5393__auto__","m__5394__auto__","malli.generator/-generator","goog/typeOf","m__5392__auto__","cljs.core/missing-protocol","malli.generator/Generator","this","options","p__39116","map__39117","cljs.core/--destructure-map","cljs.core.get","malli.generator/-never-gen","original-generator-schema","_options","cljs.core/with-meta","clojure.test.check.generators.such_that","_","cljs.core.ex_info","malli.core.form","G__39126","cljs.core.assoc","clojure.test.check.generators/any","malli.generator/-unreachable-gen?","g","cljs.core/meta","cljs.core/boolean","malli.generator/-not-unreachable","malli.generator/-random","seed","clojure.test.check.random.make_random","malli.generator/-recur","schema","cljs.core.println","malli.generator/-maybe-recur","malli.generator/-min-max","map__39159","min","max","gen-min","gen-max","malli.core.properties","and__5043__auto__","malli.core._fail_BANG_","or__5045__auto__","malli.generator/-double-gen","clojure.test.check.generators/double*","cljs.core.merge","malli.generator/-string-gen","map__39169","cljs.core._EQ_","clojure.test.check.generators/fmap","clojure.string/join","clojure.test.check.generators.vector","clojure.test.check.generators/char-alphanumeric","p1__39167#","clojure.test.check.generators/sized","clojure.test.check.generators/string-alphanumeric","malli.generator/-coll-gen","f","map__39176","child","malli.core.children","cljs.core/first","gen","malli.generator/generator","clojure.test.check.generators/return","p1__39174#","malli.generator/-coll-distinct-gen","map__39187","clojure.test.check.generators.vector_distinct","malli.generator/-and-gen","temp__5806__auto__","G__39195","G__39196","malli.core.validator","malli.generator/-or-gen","gs","cljs.core/not-empty","cljs.core.into","p1__39198#","cljs.core.keep","clojure.test.check.generators/one-of","malli.generator/-multi-gen","p1__39203#","G__39208","G__39209","cljs.core/last","malli.core.entries","malli.generator/-map-gen","entries","value-gen","k","s","G__39215","v","gens-req","p1__39211#","cljs.core.remove","cljs.core.map","p__39219","vec__39220","cljs.core.nth","gen-opt","p1__39212#","cljs.core.filter","p__39225","vec__39226","G__39237","cljs.core.conj","cljs.core.apply","clojure.test.check.generators/tuple","cljs.core/not-any?","p__39239","vec__39241","req","opt","cljs.core.concat","clojure.test.check.generators.tuple","malli.generator/-map-of-gen","map__39250","vec__39251","k-gen","v-gen","p1__39245#","opts","cljs.core/some","p1__39247#","malli.generator/-identify-ref-schema","malli.core/-options","malli.core._registry","malli.registry/-schemas","malli.core/-ref","malli.generator/-ref-gen","ref-id","cljs.core/force","cljs.core.get_in","scalar-ref-gen","cljs.core/Delay","dschema","malli.core.deref","G__39270","G__39271","G__39272","cljs.core/assoc-in","cljs.core/realized?","p1__39265#","clojure.test.check.generators/recursive-gen","G__39273","G__39274","malli.generator/-=>-gen","output-generator","G__39279","G__39280","malli.core/-function-info","malli.core._instrument","malli.generator/generate","malli.generator/-function-gen","p1__39283#","malli.generator/-regex-generator","malli.core/-regex-op?","G__39287","malli.generator/entry->schema","e","cljs.core/vector?","malli.generator/-cat-gen","p1__39292#","p1__39293#","cljs.core/concat","malli.generator/-alt-gen","p1__39300#","cljs.core/every?","malli.generator/-?-gen","malli.core/-get","malli.generator/-*-gen","G__39318","p1__39311#","malli.generator/-repeat-gen","cljs.core/identity","G__39325","p1__39320#","malli.generator/-qualified-ident-gen","mk-value-with-ns","value-with-ns-gen-size","pred","temp__5802__auto__","namespace-unparsed","G__39334","G__39335","cljs.core/name","malli.generator/-qualified-keyword-gen","cljs.core/keyword","clojure.test.check.generators/keyword","cljs.core/qualified-keyword?","clojure.test.check.generators/keyword-ns","malli.generator/-qualified-symbol-gen","cljs.core/symbol","clojure.test.check.generators/symbol","cljs.core/qualified-symbol?","clojure.test.check.generators/symbol-ns","js/malli","js/malli.generator","js/malli.generator.-schema-generator","method-table__5642__auto__","cljs.core.atom","prefer-table__5643__auto__","method-cache__5644__auto__","cached-hierarchy__5645__auto__","hierarchy__5646__auto__","fexpr__39338","cljs.core/MultiFn","cljs.core.symbol","malli.generator/-schema-generator","malli.core.type","cljs.spec.gen.alpha/gen-for-pred","p1__39380#","cljs.core.not_EQ_","clojure.test.check.generators/any-printable","cljs.core/inc","clojure.test.check.generators/nat","cljs.core.comp","cljs.core/dec","cljs.core/-","cljs.core/any?","malli.core.into_schema","malli.core.options","G__39428","G__39429","cljs.core/set","clojure.test.check.generators/elements","G__39448","G__39449","G__39450","p1__39455#","clojure.test.check.generators/large-integer*","props","clojure.test.check.generators/boolean","clojure.test.check.generators/uuid","G__39467","G__39468","G__39470","G__39471","G__39474","G__39475","G__39480","G__39481","G__39482","G__39483","clojure.test.check.generators/not-empty","malli.generator/-create-from-elements","G__39495","malli.generator/-create-from-gen","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","malli.generator/-create-from-schema","G__39502","malli.generator/-create-from-fmap","temp__5808__auto__","fmap","malli.core.eval","malli.generator/-create","malli.core.type_properties","var_args","G__39514","js/Error","?schema","malli.generator.generator","malli.core.schema","p1__39512#","malli.core/-cached","G__39518","p__39519","map__39520","?gen-or-schema","malli.generator.generate","size","clojure.test.check.generators/generator?","clojure.test.check.rose-tree/root","clojure.test.check.generators/call-gen","G__39525","malli.generator/sample","p__39527","map__39528","malli.generator.sample","clojure.test.check.generators/make-size-range-seq","p1__39521#","p2__39522#","clojure.test.check.generators/lazy-random-states","cljs.core.take","G__39533","malli.generator/function-checker","p__39536","map__39537","malli.generator.function_checker","=>iterations","check","map__39539","input","output","input-generator","output-validator","validate","args","G__39540","map__39541","result","shrunk","p1__39529#","clojure.test.check.properties/for-all*","clojure.test.check/quick-check","smallest","explain-input","malli.core.explain","response","e39543","explain-output","G__39544","cljs.core/ex-message","cljs.core.update","cljs.core.dissoc","pred__39545","expr__39546","cljs.core/=","checkers","p1__39530#","malli.core/-children","x","p1__39531#","cljs.core/seq","malli.core/-type","G__39557","malli.generator/check","malli.generator.check","p1__39555#","malli.core/-update-options"],"sourcesContent":["(ns malli.generator\n  (:require [clojure.spec.gen.alpha :as ga]\n            [clojure.string :as str]\n            [clojure.test.check :as check]\n            [clojure.test.check.generators :as gen]\n            [clojure.test.check.properties :as prop]\n            [clojure.test.check.random :as random]\n            [clojure.test.check.rose-tree :as rose]\n            [malli.core :as m]\n            [malli.registry :as mr]\n            #?(:clj [borkdude.dynaload :as dynaload])))\n\n(declare generator generate -create)\n\n(defprotocol Generator\n  (-generator [this options] \"returns generator for schema\"))\n\n;;\n;; generators\n;;\n\n\n;; # Notes for implementors\n;;\n;; For the most part, -schema-generator is a pretty direct translation from schemas to generators.\n;; However, the naive implementation of recursive ref's (creating a generator for the dereferenced ref\n;; and cutting off the generation at a certain depth) tends to create exponentially large test cases.\n;;\n;; We use a more sophisticated algorithm to achieve linearly sized test cases with recursive refs.\n;; The next section describes the strategy implementors should use to participate in this improved behavior.\n;; The theory behind this strategy is described in the section below (\"Approach for recursive generators\").\n;;\n;; ## Implementation strategy\n;;\n;; Say you have a composite schema you want to generate values for. You should extend `-schema-generator` and\n;; call `generator` recursively on the `m/children`. Now, for every child generator, you need to consider the case\n;; that the child generator generates no values, and how this might change the final generator.\n;;\n;; Use `-unreachable-gen?` to test whether your child generator generates no values (we'll call this an \"unreachable\" schema/generator).\n;; If your parent generator cannot generate values, use `-never-gen` to return an unreachable generator.\n;; \n;; Here are a few examples---compare them with the logic in their respective -schema-generator methods:\n;;   [:maybe M] would generate like :nil if M were unreachable.\n;;   [:map [:a M]] would itself be unreachable if M were unreachable.\n;;   [:map [:a {:optional true} M]] would generate like [:map] if M were unreachable.\n;;   [:vector M] would generate like [:= []] if M were unreachable.\n;;   [:vector {:min 1} M] would itself be unreachable if M were unreachable.\n\n(defn -never-gen\n  \"Return a generator of no values that is compatible with -unreachable-gen?.\"\n  [{::keys [original-generator-schema] :as _options}]\n  (with-meta (gen/such-that (fn [_]\n                              (throw (ex-info\n                                      (str \"Cannot generate values due to infinitely expanding schema: \"\n                                           (if original-generator-schema\n                                             (m/form original-generator-schema)\n                                             \"<no schema form>\"))\n                                      (cond-> {}\n                                        original-generator-schema (assoc :schema (m/form original-generator-schema))))))\n                            gen/any)\n             {::never-gen true\n              ::original-generator-schema original-generator-schema}))\n\n(defn -unreachable-gen?\n  \"Returns true iff generator g generators no values.\"\n  [g] (-> (meta g) ::never-gen boolean))\n\n(defn -not-unreachable [g] (when-not (-unreachable-gen? g) g))\n\n(defn- -random [seed] (if seed (random/make-random seed) (random/make-random)))\n\n(defn ^:deprecated -recur [schema options]\n  (println (str `-recur \" is deprecated, please update your generators. See instructions in malli.generator.\"))\n  [true options])\n\n(defn ^:deprecated -maybe-recur [schema options]\n  (println (str `-maybe-recur \" is deprecated, please update your generators. See instructions in malli.generator.\"))\n  options)\n\n(defn -min-max [schema options]\n  (let [{:keys [min max] gen-min :gen/min gen-max :gen/max} (m/properties schema options)]\n    (when (and min gen-min (< gen-min min))\n      (m/-fail! ::invalid-property {:key :gen/min, :value gen-min, :min min}))\n    (when (and max gen-max (> gen-max max))\n      (m/-fail! ::invalid-property {:key :gen/max, :value gen-min, :max min}))\n    {:min (or gen-min min)\n     :max (or gen-max max)}))\n\n(defn- -double-gen [options] (gen/double* (merge {:infinite? false, :NaN? false} options)))\n\n(defn- -string-gen [schema options]\n  (let [{:keys [min max]} (-min-max schema options)]\n    (cond\n      (and min (= min max)) (gen/fmap str/join (gen/vector gen/char-alphanumeric min))\n      (and min max) (gen/fmap str/join (gen/vector gen/char-alphanumeric min max))\n      min (gen/fmap str/join (gen/sized #(gen/vector gen/char-alphanumeric min (+ min %))))\n      max (gen/fmap str/join (gen/vector gen/char-alphanumeric 0 max))\n      :else gen/string-alphanumeric)))\n\n(defn- -coll-gen [schema f options]\n  (let [{:keys [min max]} (-min-max schema options)\n        child (-> schema m/children first)\n        gen (generator child options)]\n    (if (-unreachable-gen? gen)\n      (if (<= (or min 0) 0 (or max 0))\n        (gen/fmap f (gen/return []))\n        (-never-gen options))\n      (gen/fmap f (cond\n                    (and min (= min max)) (gen/vector gen min)\n                    (and min max) (gen/vector gen min max)\n                    min (gen/sized #(gen/vector gen min (+ min %)))\n                    max (gen/vector gen 0 max)\n                    :else (gen/vector gen))))))\n\n(defn- -coll-distinct-gen [schema f options]\n  (let [{:keys [min max]} (-min-max schema options)\n        child (-> schema m/children first)\n        gen (generator child options)]\n    (gen/fmap f (if (-unreachable-gen? gen)\n                  (if (<= (or min 0) 0 (or max 0))\n                    (gen/return [])\n                    (-never-gen options))\n                  (gen/vector-distinct gen {:min-elements min, :max-elements max, :max-tries 100})))))\n\n(defn -and-gen [schema options]\n  (if-some [gen (-not-unreachable (-> schema (m/children options) first (generator options)))]\n    (gen/such-that (m/validator schema options) gen 100)\n    (-never-gen options)))\n\n(defn -or-gen [schema options]\n  (if-some [gs (not-empty\n                (into [] (keep #(-not-unreachable (generator % options)))\n                      (m/children schema options)))]\n    (gen/one-of gs)\n    (-never-gen options)))\n\n(defn -multi-gen [schema options]\n  (if-some [gs (not-empty\n                (into [] (keep #(-not-unreachable (generator (last %) options)))\n                      (m/entries schema options)))]\n    (gen/one-of gs)\n    (-never-gen options)))\n\n(defn -map-gen [schema options]\n  (let [entries (m/entries schema)\n        value-gen (fn [k s] (let [g (generator s options)]\n                              (cond->> g\n                                (-not-unreachable g)\n                                (gen/fmap (fn [v] [k v])))))\n        gens-req (->> entries\n                      (remove #(-> % last m/properties :optional))\n                      (map (fn [[k s]] (value-gen k s))))\n        gen-opt (->> entries\n                     (filter #(-> % last m/properties :optional))\n                     (map (fn [[k s]] (let [g (-not-unreachable (value-gen k s))]\n                                        (gen/one-of (cond-> [(gen/return nil)]\n                                                      g (conj g))))))\n                     (apply gen/tuple))]\n    (if (not-any? -unreachable-gen? gens-req)\n      (gen/fmap (fn [[req opt]] (into {} (concat req opt))) (gen/tuple (apply gen/tuple gens-req) gen-opt))\n      (-never-gen options))))\n\n(defn -map-of-gen [schema options]\n  (let [{:keys [min max]} (-min-max schema options)\n        [k-gen v-gen :as gs] (map #(generator % options) (m/children schema options))\n        opts (cond\n               (and min (= min max)) {:num-elements min}\n               (and min max) {:min-elements min :max-elements max}\n               min {:min-elements min}\n               max {:max-elements max}\n               :else {})]\n    (if (some -unreachable-gen? gs)\n      (if (= 0 (or min 0) (or max 0))\n        (gen/return {})\n        (-never-gen options))\n      (gen/fmap #(into {} %) (gen/vector-distinct (gen/tuple k-gen v-gen) opts)))))\n\n#?(:clj\n   (defn -re-gen [schema options]\n     ;; [com.gfredericks/test.chuck \"0.2.10\"+]\n     (if-let [string-from-regex @(dynaload/dynaload 'com.gfredericks.test.chuck.generators/string-from-regex {:default nil})]\n       (let [re (or (first (m/children schema options)) (m/form schema options))]\n         (string-from-regex (re-pattern (str/replace (str re) #\"^\\^?(.*?)(\\$?)$\" \"$1\"))))\n       (m/-fail! :test-chuck-not-available))))\n\n;; # Approach for recursive generators\n;;\n;; `-ref-gen` is the only place where recursive generators can be created, and we use `gen/recursive-gen`\n;; to handle the recursion. The challenge is that gen/recursive-gen requires _two_ arguments: the base\n;; case (scalar gen) and the recursive case (container gen). We need to automatically split the schema argument into\n;; these two cases.\n;;\n;; The main insight we use is that a base case for the schema cannot contain recursive references to itself.\n;; A particularly useful base case is simply to \"delete\" all recursive references. To simulate this, we have the concept of\n;; an \"unreachable\" generator, which represents a \"deleted\" recursive reference.\n;;\n;; For infinitely expanding schemas, this will return an unreachable generator--when the base case generator is used,\n;; the error message in `-never-gen` will advise users that their schema is infinite.\n;; \n;; \n;; Examples of base cases of some recursive schemas:\n;;\n;; Schema:    [:schema {:registry {::cons [:maybe [:vector [:tuple pos-int? [:ref ::cons]]]]}} ::cons]\n;; Base case: [:schema {:registry {::cons [:nil                                            ]}} ::cons]\n;;\n;; Schema:    [:schema\n;;             {:registry {::ping [:tuple [:= \"ping\"] [:maybe [:ref ::pong]]]\n;;                         ::pong [:tuple [:= \"pong\"] [:maybe [:ref ::ping]]]}}\n;;             ::ping]\n;; Base case: [:schema\n;;             {:registry {::ping [:tuple [:= \"ping\"] [:maybe [:ref ::pong]]]\n;;                         ::pong [:tuple [:= \"pong\"] :nil                  ]}}\n;;             ::ping]\n;;\n;; Once we have the base case, we first need determine if the schema is recursive---it's recursive\n;; if more than one recursive reference was successfully \"deleted\" while creating the base case (see below for how we determine recursive references).\n;; We can then construct the recursive case by providing `gen/recursive-gen` the base case\n;; (this is why this particular base case is so useful) and then propagate the (smaller) generator\n;; supplied by `gen/recursive-gen` to convert recursive references.\n\n;; ## Identifying schema recursion\n;; \n;; Refs are uniquely identified by their paired name and scope. If we see a ref with the\n;; same name and scope as another ref we've dereferenced previously, we know that this is a recursion\n;; point back to the previously seen ref. The rest of this section explains why.\n;; \n;; Refs resolve via dynamic scope, which means its dereferenced value is the latest binding found\n;; while expanding the schema until the point of finding the ref.\n;; This makes the (runtime) scope at the ref's location part of a ref's identity---if the scope\n;; is different, then it's (possibly) not the same ref because scope determines how schemas\n;; transitively expand.\n;;\n;; To illustrate why a ref's name is an insufficient identifier, here is a schema that is equivalent to `[:= 42]`:\n;; \n;;   [:schema {:registry {::a [:schema {:registry {::a [:= 42]}}\n;;                             ;; (2)\n;;                             [:ref ::a]]}}\n;;    ;; (1)\n;;    [:ref ::a]]\n;;\n;; If we identify refs just by name, we would have incorrectly detected (2) to be an (infinitely expanding) recursive\n;; reference.\n;;\n;; In studying the previous example, we might think that since (1) and (2) deref to different schemas, it might sufficient to identify refs just by their derefs.\n;; Unfortunately this just pushes the problem elsewhere.\n;;\n;; For example, here is another schema equivalent to `[:= 42]`:\n;;\n;;   [:schema {:registry {::a [:ref ::b] ;; (2)\n;;                        ::b [:schema {:registry {::a [:ref ::b] ;; (4)\n;;                                                 ::b [:= 42]}}\n;;                             ;; (3)\n;;                             [:ref ::a]]}}\n;;    ;; (1)\n;;    [:ref ::a]]\n;;\n;; If we identified ::a by its deref, it would look like (3) deref'ing to (4)\n;; is a recursion point after witnessing (1) deref'ing to (2), since (2) == (4). Except this\n;; is wrong since it's a different ::b at (2) and (4)! OTOH, if we identified (2) and (4) with their\n;; dynamic scopes along with their form, they would be clearly different. Indeed, this\n;; is another way to identify refs: pairing their derefs with their deref's scopes.\n;; It is slightly more direct to use the ref's direct name and scope, which is why\n;; we choose that identifier. The more general insight is that any schema is identified by its form+scope\n;; (note: but only after trimming the scope of irrelevant bindings, see next pararaph).\n;; That insight may be useful for detecting recursion at places other than refs.\n;; \n;; Ref identifiers could be made smarter by trimming irrelevant entries in identifying scope.\n;; Not all scope differences are relevant, so generators may expand more than strictly necessary\n;; in the quest to find the \"same\" ref schema again. It could skip over refs that generate exactly the\n;; same values, but their scopes are uninterestingly different (eg., unused bindings are different).\n;;\n;; For example, the following schema is recursive \"in spirit\" between (1) and (2), but since ::b\n;; changes, the scope will differ, so the recursion will be detected between (2) and itself instead\n;; (where the scope is constant):\n;;\n;;   [:schema {:registry {::a [:schema {:registry {::b :boolean}}\n;;                             ;; (2)\n;;                             [:or [:ref ::a] [:ref ::b]]]}}\n;;    [:schema {:registry {::b :int}}\n;;     ;; (1)\n;;     [:or [:ref ::a] [:ref ::b]]]]\n\n(defn- -identify-ref-schema [schema]\n  {:scope (-> schema m/-options m/-registry mr/-schemas)\n   :name (m/-ref schema)})\n\n(defn -ref-gen [schema options]\n  (let [ref-id (-identify-ref-schema schema)]\n    (or (force (get-in options [::rec-gen ref-id]))\n        (let [scalar-ref-gen (delay (-never-gen options))\n              dschema (m/deref schema)]\n          (cond->> (generator dschema (assoc-in options [::rec-gen ref-id] scalar-ref-gen))\n            (realized? scalar-ref-gen) (gen/recursive-gen\n                                        #(generator dschema (assoc-in options [::rec-gen ref-id] %))))))))\n\n(defn -=>-gen [schema options]\n  (let [output-generator (generator (:output (m/-function-info schema)) options)]\n    (gen/return (m/-instrument {:schema schema} (fn [& _] (generate output-generator options))))))\n\n(defn -function-gen [schema options]\n  (gen/return (m/-instrument {:schema schema, :gen #(generate % options)} options)))\n\n(defn -regex-generator [schema options]\n  (if (m/-regex-op? schema)\n    (generator schema options)\n    (let [g (generator schema options)]\n      (cond-> g\n        (-not-unreachable g) gen/tuple))))\n\n(defn- entry->schema [e] (if (vector? e) (get e 2) e))\n\n(defn -cat-gen [schema options]\n  (let [gs (->> (m/children schema options)\n                (map #(-regex-generator (entry->schema %) options)))]\n    (if (some -unreachable-gen? gs)\n      (-never-gen options)\n      (->> gs\n           (apply gen/tuple)\n           (gen/fmap #(apply concat %))))))\n\n(defn -alt-gen [schema options]\n  (let [gs (->> (m/children schema options)\n                (keep #(-regex-generator (entry->schema %) options)))]\n    (if (every? -unreachable-gen? gs)\n      (-never-gen options)\n      (gen/one-of (into [] (keep -not-unreachable) gs)))))\n\n(defn -?-gen [schema options]\n  (let [child (m/-get schema 0 nil)]\n    (if-some [g (-not-unreachable (generator child options))]\n      (if (m/-regex-op? child)\n        (gen/one-of [g (gen/return ())])\n        (gen/vector g 0 1))\n      (gen/return ()))))\n\n(defn -*-gen [schema options]\n  (let [child (m/-get schema 0 nil)]\n    (if-some [g (-not-unreachable (generator child options))]\n      (cond->> (gen/vector g)\n        (m/-regex-op? child)\n        (gen/fmap #(apply concat %)))\n      (gen/return ()))))\n\n(defn -repeat-gen [schema options]\n  (let [child (m/-get schema 0 nil)]\n    (if-some [g (-not-unreachable (-coll-gen schema identity options))]\n      (cond->> g\n        (m/-regex-op? child)\n        (gen/fmap #(apply concat %)))\n      (gen/return ()))))\n\n(defn -qualified-ident-gen [schema mk-value-with-ns value-with-ns-gen-size pred gen]\n  (if-let [namespace-unparsed (:namespace (m/properties schema))]\n    (gen/fmap (fn [k] (mk-value-with-ns (name namespace-unparsed) (name k))) value-with-ns-gen-size)\n    (gen/such-that pred gen)))\n\n(defn -qualified-keyword-gen [schema]\n  (-qualified-ident-gen schema keyword gen/keyword qualified-keyword? gen/keyword-ns))\n\n(defn -qualified-symbol-gen [schema]\n  (-qualified-ident-gen schema symbol gen/symbol qualified-symbol? gen/symbol-ns))\n\n(defmulti -schema-generator (fn [schema options] (m/type schema options)) :default ::default)\n\n(defmethod -schema-generator ::default [schema options] (ga/gen-for-pred (m/validator schema options)))\n\n(defmethod -schema-generator :> [schema options] (-double-gen {:min (-> schema (m/children options) first inc)}))\n(defmethod -schema-generator :>= [schema options] (-double-gen {:min (-> schema (m/children options) first)}))\n(defmethod -schema-generator :< [schema options] (-double-gen {:max (-> schema (m/children options) first dec)}))\n(defmethod -schema-generator :<= [schema options] (-double-gen {:max (-> schema (m/children options) first)}))\n(defmethod -schema-generator := [schema options] (gen/return (first (m/children schema options))))\n(defmethod -schema-generator :not= [schema options] (gen/such-that #(not= % (-> schema (m/children options) first)) gen/any-printable 100))\n(defmethod -schema-generator 'pos? [_ _] (gen/one-of [(-double-gen {:min 0.00001}) (gen/fmap inc gen/nat)]))\n(defmethod -schema-generator 'neg? [_ _] (gen/one-of [(-double-gen {:max -0.0001}) (gen/fmap (comp dec -) gen/nat)]))\n\n(defmethod -schema-generator :not [schema options] (gen/such-that (m/validator schema options) (ga/gen-for-pred any?) 100))\n(defmethod -schema-generator :and [schema options] (-and-gen schema options))\n(defmethod -schema-generator :or [schema options] (-or-gen schema options))\n(defmethod -schema-generator :orn [schema options] (-or-gen (m/into-schema :or (m/properties schema) (map last (m/children schema)) (m/options schema)) options))\n(defmethod -schema-generator ::m/val [schema options] (generator (first (m/children schema)) options))\n(defmethod -schema-generator :map [schema options] (-map-gen schema options))\n(defmethod -schema-generator :map-of [schema options] (-map-of-gen schema options))\n(defmethod -schema-generator :multi [schema options] (-multi-gen schema options))\n(defmethod -schema-generator :vector [schema options] (-coll-gen schema identity options))\n(defmethod -schema-generator :sequential [schema options] (-coll-gen schema identity options))\n(defmethod -schema-generator :set [schema options] (-coll-distinct-gen schema set options))\n(defmethod -schema-generator :enum [schema options] (gen/elements (m/children schema options)))\n\n(defmethod -schema-generator :maybe [schema options]\n  (let [g (-> schema (m/children options) first (generator options) -not-unreachable)]\n    (gen/one-of (cond-> [(gen/return nil)]\n                  g (conj g)))))\n\n(defmethod -schema-generator :tuple [schema options]\n  (let [gs (map #(generator % options) (m/children schema options))]\n    (if (not-any? -unreachable-gen? gs)\n      (apply gen/tuple gs)\n      (-never-gen options))))\n#?(:clj (defmethod -schema-generator :re [schema options] (-re-gen schema options)))\n(defmethod -schema-generator :any [_ _] (ga/gen-for-pred any?))\n(defmethod -schema-generator :nil [_ _] (gen/return nil))\n(defmethod -schema-generator :string [schema options] (-string-gen schema options))\n(defmethod -schema-generator :int [schema options] (gen/large-integer* (-min-max schema options)))\n(defmethod -schema-generator :double [schema options]\n  (gen/double* (merge (let [props (m/properties schema options)]\n                        {:infinite? (get props :gen/infinite? false)\n                         :NaN? (get props :gen/NaN? false)})\n                      (-min-max schema options))))\n(defmethod -schema-generator :boolean [_ _] gen/boolean)\n(defmethod -schema-generator :keyword [_ _] gen/keyword)\n(defmethod -schema-generator :symbol [_ _] gen/symbol)\n(defmethod -schema-generator :qualified-keyword [schema _] (-qualified-keyword-gen schema))\n(defmethod -schema-generator :qualified-symbol [schema _] (-qualified-symbol-gen schema))\n(defmethod -schema-generator :uuid [_ _] gen/uuid)\n\n(defmethod -schema-generator :=> [schema options] (-=>-gen schema options))\n(defmethod -schema-generator :function [schema options] (-function-gen schema options))\n(defmethod -schema-generator 'ifn? [_ _] gen/keyword)\n(defmethod -schema-generator :ref [schema options] (-ref-gen schema options))\n(defmethod -schema-generator :schema [schema options] (generator (m/deref schema) options))\n(defmethod -schema-generator ::m/schema [schema options] (generator (m/deref schema) options))\n\n(defmethod -schema-generator :merge [schema options] (generator (m/deref schema) options))\n(defmethod -schema-generator :union [schema options] (generator (m/deref schema) options))\n(defmethod -schema-generator :select-keys [schema options] (generator (m/deref schema) options))\n\n(defmethod -schema-generator :cat [schema options] (-cat-gen schema options))\n(defmethod -schema-generator :catn [schema options] (-cat-gen schema options))\n(defmethod -schema-generator :alt [schema options] (-alt-gen schema options))\n(defmethod -schema-generator :altn [schema options] (-alt-gen schema options))\n\n(defmethod -schema-generator :? [schema options] (-?-gen schema options))\n(defmethod -schema-generator :* [schema options] (-*-gen schema options))\n(defmethod -schema-generator :+ [schema options] (gen/not-empty (-*-gen schema options)))\n(defmethod -schema-generator :repeat [schema options] (-repeat-gen schema options))\n\n;;\n;; Creating a generator by different means, centralized under [[-create]]\n;;\n\n(defn- -create-from-elements [props]\n  (some-> (:gen/elements props) gen/elements))\n\n(defn- -create-from-gen\n  [props schema options]\n  (or (:gen/gen props)\n      (when-not (:gen/elements props)\n        (if (satisfies? Generator schema)\n          (-generator schema options)\n          (-schema-generator schema (assoc options ::original-generator-schema schema))))))\n\n(defn- -create-from-schema [props options]\n  (some-> (:gen/schema props) (generator options)))\n\n(defn- -create-from-fmap [props schema options]\n  (when-some [fmap (:gen/fmap props)]\n    (gen/fmap (m/eval fmap (or options (m/options schema)))\n              (or (-create-from-elements props)\n                  (-create-from-schema props options)\n                  (-create-from-gen props schema options)\n                  (gen/return nil)))))\n\n(defn- -create [schema options]\n  (let [props (merge (m/type-properties schema)\n                     (m/properties schema))]\n    (or (-create-from-fmap props schema options)\n        (-create-from-elements props)\n        (-create-from-schema props options)\n        (-create-from-gen props schema options)\n        (m/-fail! ::no-generator {:options options\n                                  :schema schema}))))\n\n;;\n;; public api\n;;\n\n(defn generator\n  ([?schema]\n   (generator ?schema nil))\n  ([?schema options]\n   (if (::rec-gen options)\n     ;; disable cache while calculating recursive schemas. caches don't distinguish options.\n     (-create (m/schema ?schema options) options)\n     (m/-cached (m/schema ?schema options) :generator #(-create % options)))))\n\n(defn generate\n  ([?gen-or-schema]\n   (generate ?gen-or-schema nil))\n  ([?gen-or-schema {:keys [seed size] :or {size 30} :as options}]\n   (let [gen (if (gen/generator? ?gen-or-schema) ?gen-or-schema (generator ?gen-or-schema options))]\n     (rose/root (gen/call-gen gen (-random seed) size)))))\n\n(defn sample\n  ([?gen-or-schema]\n   (sample ?gen-or-schema nil))\n  ([?gen-or-schema {:keys [seed size] :or {size 10} :as options}]\n   (let [gen (if (gen/generator? ?gen-or-schema) ?gen-or-schema (generator ?gen-or-schema options))]\n     (->> (gen/make-size-range-seq size)\n          (map #(rose/root (gen/call-gen gen %1 %2))\n               (gen/lazy-random-states (-random seed)))\n          (take size)))))\n\n;;\n;; functions\n;;\n\n(defn function-checker\n  ([?schema] (function-checker ?schema nil))\n  ([?schema {::keys [=>iterations] :or {=>iterations 100} :as options}]\n   (let [schema (m/schema ?schema options)\n         check (fn [schema]\n                 (let [{:keys [input output]} (m/-function-info schema)\n                       input-generator (generator input options)\n                       output-validator (m/validator output options)\n                       validate (fn [f args] (output-validator (apply f args)))]\n                   (fn [f]\n                     (let [{:keys [result shrunk]} (->> (prop/for-all* [input-generator] #(validate f %))\n                                                        (check/quick-check =>iterations))\n                           smallest (-> shrunk :smallest first)]\n                       (when-not (true? result)\n                         (let [explain-input (m/explain input smallest)\n                               response (when-not explain-input\n                                          (try (apply f smallest) (catch #?(:clj Exception, :cljs js/Error) e e)))\n                               explain-output (when-not explain-input (m/explain output response))]\n                           (cond-> shrunk\n                             explain-input (assoc ::explain-input explain-input)\n                             explain-output (assoc ::explain-output explain-output)\n                             (ex-message result) (-> (update :result ex-message)\n                                                     (dissoc :result-data)))))))))]\n     (condp = (m/type schema)\n       :=> (check schema)\n       :function (let [checkers (map #(function-checker % options) (m/-children schema))]\n                   (fn [x] (->> checkers (keep #(% x)) (seq))))\n       (m/-fail! ::invalid-function-schema {:type (m/-type schema)})))))\n\n(defn check\n  ([?schema f] (check ?schema f nil))\n  ([?schema f options]\n   (let [schema (m/schema ?schema options)]\n     (m/explain (m/-update-options schema #(assoc % ::m/function-checker function-checker)) f))))\n"]}